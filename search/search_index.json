{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"edfrw A Python library for reading and writing European Data Format (EDF) files. EDF is a format for data storage that is particularly useful for recording biological and physical signals. The format is described in detail on the EDF website . Links The source code is on GitHub. The code is licensed under the GNU General Public License .","title":"Overview"},{"location":"#edfrw","text":"A Python library for reading and writing European Data Format (EDF) files. EDF is a format for data storage that is particularly useful for recording biological and physical signals. The format is described in detail on the EDF website .","title":"edfrw"},{"location":"#links","text":"The source code is on GitHub. The code is licensed under the GNU General Public License .","title":"Links"},{"location":"license/","text":"License edfrw is a Python library for reading and writing European Data Format (EDF) files. Copyright (C) 2017-2022 Antonio Gonz\u00e1lez This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/ .","title":"License"},{"location":"license/#license","text":"edfrw is a Python library for reading and writing European Data Format (EDF) files. Copyright (C) 2017-2022 Antonio Gonz\u00e1lez This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/ .","title":"License"},{"location":"api/api/","text":"API edfrw consists of three modules: Headers Reader Writer","title":"API"},{"location":"api/api/#api","text":"edfrw consists of three modules: Headers Reader Writer","title":"API"},{"location":"api/headers/","text":"edfrw.headers Manage EDF file headers. EdfHeader ( subject_code = '' , subject_sex = '' , subject_dob = '' , subject_name = '' , experiment_id = '' , investigator_id = '' , equipment_code = '' , duration_of_data_record = 0 , date_time = None , reserved = '' , signals = []) The header in a EDF file. Attributes: Name Type Description duration_of_data_record number number_of_bytes_in_header int number_of_data_records int number_of_signals int recording_id object of class EdfRecordingId reserved str signals list of EdfSignal startdate datetime . date starttime datetime . time subject_id object of class EdfSubjectId version str, always '0' Initialises an EDF header. Parameters: Name Type Description Default subject_code str , default '' subject_sex str , default '' subject_dob str , default '' subject_name The parameters subject_* are used to construct an object of class::EdfSubjectId . See that class for details. '' experiment_id str , default '' investigator_id str , default '' equipment_code str , default '' date_time str or datetime or None, default The parameters experiment_id , investigator_id , equipment_code and date_time are used to construct and object of class::EdfRecordingId . See that class for details. None duration_of_data_record number , default This can be a float, but is is recommended to be an integer value 0 reserved str , default Must be an empty string if the file conforms to the EDF format, or \u2018EDF+C\u2019 or \u2018EDF+D\u2019 if the file includes an annotations signal (EDF+ format). '' signals list of EdfSignal objects, default A list of objects of class::Signal [] __str__ () Display the contents of the header. duration_of_data_record () writable property Get or set the duration (in seconds) of the data record. This value is recommended (but not required) to be an integer. number_of_bytes_in_header () writable property Get or set the number of bytes in the data header. This value depends on the number of signals, so it should be updated whenever the number of signals changes. number_of_signals () property Get the number of signals in the EDF file. pack () Return the header as a bytes object. The header record, which includes the subject, recording, and signal(s) attributes, are concatenated into a single bytes (ascii string) object, as required by the EDF specification. This object can be then used to e.g. write the header record in an opened EDF file. Returns: Name Type Description main_hdr str ( ascii ) The record header, formatted as per the EDF requirements. recording_id () writable property Get or set the recording identification. The recording ID can be a single string with values [start_str, startdate, experiment_id, investigator_id, equipment_code] separated by spaces (as is the case when reading the recording ID from the header of and EDF file), or an object of class EdfRecordingId . Examples: Using one, space-separated string of values: >>> rec_id = ( \"start_str startdate experiment_id \" + \"investigator_id equipment_code\") >>> header . recording_id = rec_id Using EdfRecordingId: >>> rec_id = EdfRecordingId ( startdate , experiment_id , ... investigator_id , equipment_code ) >>> header . recording_id = rec_id signals () writable property Get or set the list of signals in an EDF file. This attribute is a list of EdfSignal signal objects. startdate () writable property Set or get the recording start date. Parameters: Name Type Description Default value str or datetime It must be either (a) a string \u2018yyyy-mm-dd\u2019, e.g. \u20182016-10-25\u2019, or (b) a string \u2018d.m.y\u2019 as required by EDF, e.g. \u201816.10.25\u2019, or (c) a datetime object required Returns: Name Type Description startdate datetime object starttime () writable property Get or set the recording start time. Parameters: Name Type Description Default value str or datetime It must be either (a) a string \u2018H.M.S\u2019 as required by EDF, e.g. \u201812.15.05\u2019, or (b) a string in standard format \u2018H:M:S\u2019, e.g. \u201812:15:05\u2019, or (b) a datetime object. required subject_id () writable property Get or set the subject (patient) ID record. The subject ID can be a single string with values [code, sex, dob, name] separated by spaces (as is the case when reading the patient ID from the header of and EDF file), or an object of class EdfSubjectId . Examples: Use a single string, values are space-separated. >>> header . subject_id = \"the_code X 1990-01-01 the_name\" or use EdfSubjectID >>> id = EdfSubjectID ( code , sex , dob , name ) >>> header . subject_id = id EdfRecordingId ( startdate = None , experiment_id = '' , investigator_id = '' , equipment_code = '' ) Recording identification. The \u2018local recording identification field\u2019 is a string of 80 characters in the header of a EDF file. It contains information about the start date, experiment ID, investigator ID, and equipment code, each of these separated by a space. This class handles that information. It is seldom useful on its own but rather as an attribute of class::Header . Attributes: Name Type Description equipment_code str experiment_id str investigator_id str startdate datetime . date The \u2018local recording identification field\u2019. The recording identification field forms part of the EDF header. All these subfields together will be concatenated (separated by spaces) to form one string which must not exceed 80 characters. Note that the text \u2018Startdate\u2019 is always prepended to this string, and this must betaken into account for the character count. Fields that are unknown (empty strings) will be replaced by an \u2018X\u2019 as per the EDF specification. Parameters: Name Type Description Default startdate str or datetime or None, default The start date. Expected to be: (a) a string in isoformat (\u2018yyyy-mm-dd\u2019), or (b) a datetime instance, as in e.g. datetime.now(), or (c) a date string with format \u2018%d-%b-%Y\u2019, as in e.g. \u201802-AUG-1951\u2019, which is the format required by EDF for this field, or (d) None, in which case the current date will be used None experiment_id str , default \u201cThe hospital administration code of the investigation, i.e. EEG number\u201d (Kemp, 2003) '' investigator_id str , default \u201cA code identifying the responsible investigator\u201d (Kemp, 2003) '' equipment_code str , default \u201cA code specifying the used equipment\u201d (Kemp, 2003) '' equipment_code () writable property Get or set the equipment code. Any spaces will be replaced by underscores. experiment_id () writable property Get or set the experiment ID. Any spaces will be replaced by underscores, as required by EDF. investigator_id () writable property Get or set the investigator ID. Any spaces will be replaced by underscores, as required by EDF. startdate () writable property Get or set the recording start date. To set the date, any of these values are acceptable: (a) a string in isoformat (\u2018yyyy-mm-dd\u2019), or (b) a datetime instance, as in e.g. datetime.now(), or (c) a date string with format \u2018%d-%b-%Y\u2019, which is the format required by EDF for this field. (d) None, in which case the current date will be used. In all cases startdate will be saved internally as a datetime object. to_str () Return the recording identification as a single string. The local recording identification in an EDF file must be a string no longer than 80 characters. This function concatenates the recording attributes to create such a string. This is useful for making the full EDF header record. Returns: Name Type Description rec_id str A string containing the recording identification in the format specified by EDF. EdfSignal ( label = '' , transducer_type = '' , physical_dim = '' , physical_min =- 32768 , physical_max = 32767 , digital_min =- 32768 , digital_max = 32767 , prefiltering = '' , number_of_samples_in_data_record = 0 , sampling_freq = 0 ) Properties of a signal. These properties are stored in the header of an EDF file (after the first 256 bytes which contain the \u2018main\u2019 header). Each signal header is 256 bytes long. Attributes: Name Type Description digital_max int digital_min int gain number label str number_of_samples_in_data_record int physical_dim str physical_max number physical_min number prefiltering str reserved str sampling_freq number transducer_type str Examples: Example 1: A voltage signal digitised with a 12-bit ADC, single-ended, input range 0 to 5 V. Sampling rate (fs) is 30 Hz. saving_period_s is how often (in seconds) the data are saved to disk. >>> fs = 30 >>> signal = edfrw . EdfSignal ( label = 'ADC' , sampling_freq = fs , ... physical_dim = \"V\" , ... number_of_samples_in_data_record = saving_period_s * fs , ... physical_min = 0 , physical_max = 5 , ... digital_min = 0 , digital_max = 4095 ) Example 2: A voltage signal, digitised with a 16-bit ADC with input range -10 to 10 V. Sampling rate (fs) is 1000 Hz. >>> fs = 1000 >>> signal = edfrw . EdfSignal ( label = 'ADC' , sampling_freq = fs , ... number_of_samples_in_data_record = saving_period_s * fs , ... physical_dim = \"V\" , physical_min =- 10 , physical_max = 10 , ... digital_min =- 0x8000 , digital_max = 0x7fff ) Example 3: A digital signal as a boolean (off = 0, on = 1) >>> signal = edfrw . EdfSignal ( label = 'ON-OFF' , sampling_freq = fs , ... number_of_samples_in_data_record = saving_period_s * fs , ... physical_min = 0 , physical_max = 1 , digital_min = 0 , ... digital_max = 1 ) Properties of a signal in an EDF file. Parameters: Name Type Description Default label str , max . length '' transducer_type str of size 80, default The type of sensor used, e.g. \u2018thermistor\u2019 or \u2018Ag-AgCl electrode\u2019. '' physical_dim str , max . length The physical dimension. A string that must start with a prefix (e.g. \u2018u\u2019 for \u2018micro\u2019) followed by the basic dimension (e.g. \u2018V\u2019 for volts). Other examples of basic dimensions are \u2018K\u2019, \u2018degC\u2019 or \u2018degF\u2019 for temperature, and \u2018%\u2019 for SaO2. Powers are denoted by \u2018^\u2019, as in \u2018V^2/Hz\u2019. An empty string represents an uncalibrated signal. For standards on labels and units, see http://www.edfplus.info/specs/edftexts.html '' physical_min number , default -32768 physical_max number , default The physical minimum and maximum should correspond to the digital extremes digital_min and digital_max and be expressed in the physical dimension physical_dim . The values of physical_min and physical_max must be different. 32767 digital_min number , default -32768 digital_max number , default \u201cThe digital minimum and maximum of each signal should specify the extreme values that can occur in the data records. These often are the extreme output values of the A/D converter.\u201d (Kemp et al. 1992). digital_max must be larger than digital_min . Together, the two digital_ and the two physical_ values specify the offset and the amplification of the signal. 32767 prefiltering str , max . length Specifies if this signal was filtered; e.g. for high-pass, low-pass, or notch filtering, \u2018HP:0.1Hz\u2019, \u2018LP:75Hz\u2019, \u2018N:50Hz\u2019 '' number_of_samples_in_data_record integer , default The number of 16-bit integers that this signal occupies 0 sampling_freq number , default The sampling frequency. This subfield is not part of the EDF specification. It is added for convenience. 0 Notes Use only ascii characters. The data in EDF files are saved as two\u2019s complement, 16-bit integers. Thus, the range between digital_min and digital_max must not exceed 2**16 - 1 = 65535. dig_to_phys ( value ) Convert a digital value to a physical value. Parameters: Name Type Description Default value uint16 or array of uint16_t A digital value to convert. EDF digital values are always unsigned, 16-bit integers. required Returns: Name Type Description phys float or array of float The corresponding physical value. Notes These equations follow those used in EDFBrowser to convert from EDF to ascii ( ascii_export.cpp ) digital_max () writable property Get or set the signal\u2019s digital maximum value. digital_min () writable property Get or set the signal\u2019s digital minimum value. gain () property Get the signal gain. The gain maps physical to digital dimensions. This property is calculated automatically whenever the digital or physical min/max values are set. label () writable property Get or set the signal label. number_of_samples_in_data_record () writable property Get or set the number of samples in each data record. phys_to_dig ( value ) Convert a physical value to a digital value. Parameters: Name Type Description Default value float or array of floats The physical value(s) to convert required Returns: Name Type Description dig uint16_t or array of uint16_t The digital value Notes Follows the equation of a straight line (point-slope form): y = m * (x - x1) + y1 x = (y - y1)/m + x1 physical_dim () writable property Get or set the signal\u2019s physical dimension. physical_max () writable property Get or set the signal\u2019s physical maximum. physical_min () writable property Get or set the signal\u2019s physical minimum. prefiltering () writable property Get or set the signal\u2019s prefiltering information. Examples: If the signal was low-pass filtered with a 10 Hz cut-off, >>> signal . prefiltering = \"LP:10Hz\" transducer_type () writable property Get or set the transducer type. EdfSubjectId ( code = '' , sex = '' , dob = '' , name = '' ) Subject (patient) identification. The subject (patient) identification is a string (80 characters long) in the header of a EDF file than contains information about the patient\u2019s code, name, sex, and date of birth. This class handles that information. It is seldom useful on its own but rather as an attribute of class::Header . Attributes: Name Type Description code str Patient code sex str Patient sex dob datetime . date Patient date of birth name str Patient name Properties that identify the subject. Parameters: Name Type Description Default code str , default Patient code '' sex str '' dob str or datetime, default Date of birth. It must be entered as: (a) a string in EDF format \u2018dd-MMM-yy\u2019, as in \u201830-DEC-1999\u2019; (b) a string in iso format \u2018yyyy-mm-dd\u2019, as in \u20181999-12-30\u2019; or (c) a datetime object. '' name str , default The patient\u2019s name '' Any field that is not known can be entered as \u2018X\u2019 (as per the EDF standard) or as an empty string \u2018\u2019. code () writable property Get or set the patient\u2019s code. dob () writable property Get or set the date of birth (DOB). If DOB is not known it must be an empty string \u2018\u2019 or \u2018X\u2019. If it is known, it must be entered as (a) a string in EDF format \u2018dd-MMM-yy\u2019, as in \u201830-DEC-1999\u2019; (b) a string in iso format \u2018yyyy-mm-dd\u2019, as in \u20181999-12-30\u2019; or (c) a datetime object. In any case the date will be stored as a datetime.date object. name () writable property Get or set the patient\u2019s name. sex () writable property Get or set the patient\u2019s sex. to_str () Return patient ID record as a single string. The patient identification record in an EDF file must be a string no longer than 80 characters. This function concatenates the patient attributes to create such a string. This is useful for making the full EDF header record. Returns: Name Type Description patient_id str A string containing patient ID in the format specified by EDF.","title":"Headers"},{"location":"api/headers/#edfrw.headers","text":"Manage EDF file headers.","title":"headers"},{"location":"api/headers/#edfrw.headers.EdfHeader","text":"The header in a EDF file. Attributes: Name Type Description duration_of_data_record number number_of_bytes_in_header int number_of_data_records int number_of_signals int recording_id object of class EdfRecordingId reserved str signals list of EdfSignal startdate datetime . date starttime datetime . time subject_id object of class EdfSubjectId version str, always '0' Initialises an EDF header. Parameters: Name Type Description Default subject_code str , default '' subject_sex str , default '' subject_dob str , default '' subject_name The parameters subject_* are used to construct an object of class::EdfSubjectId . See that class for details. '' experiment_id str , default '' investigator_id str , default '' equipment_code str , default '' date_time str or datetime or None, default The parameters experiment_id , investigator_id , equipment_code and date_time are used to construct and object of class::EdfRecordingId . See that class for details. None duration_of_data_record number , default This can be a float, but is is recommended to be an integer value 0 reserved str , default Must be an empty string if the file conforms to the EDF format, or \u2018EDF+C\u2019 or \u2018EDF+D\u2019 if the file includes an annotations signal (EDF+ format). '' signals list of EdfSignal objects, default A list of objects of class::Signal []","title":"EdfHeader"},{"location":"api/headers/#edfrw.headers.EdfHeader.__str__","text":"Display the contents of the header.","title":"__str__()"},{"location":"api/headers/#edfrw.headers.EdfHeader.duration_of_data_record","text":"Get or set the duration (in seconds) of the data record. This value is recommended (but not required) to be an integer.","title":"duration_of_data_record()"},{"location":"api/headers/#edfrw.headers.EdfHeader.number_of_bytes_in_header","text":"Get or set the number of bytes in the data header. This value depends on the number of signals, so it should be updated whenever the number of signals changes.","title":"number_of_bytes_in_header()"},{"location":"api/headers/#edfrw.headers.EdfHeader.number_of_signals","text":"Get the number of signals in the EDF file.","title":"number_of_signals()"},{"location":"api/headers/#edfrw.headers.EdfHeader.pack","text":"Return the header as a bytes object. The header record, which includes the subject, recording, and signal(s) attributes, are concatenated into a single bytes (ascii string) object, as required by the EDF specification. This object can be then used to e.g. write the header record in an opened EDF file. Returns: Name Type Description main_hdr str ( ascii ) The record header, formatted as per the EDF requirements.","title":"pack()"},{"location":"api/headers/#edfrw.headers.EdfHeader.recording_id","text":"Get or set the recording identification. The recording ID can be a single string with values [start_str, startdate, experiment_id, investigator_id, equipment_code] separated by spaces (as is the case when reading the recording ID from the header of and EDF file), or an object of class EdfRecordingId . Examples: Using one, space-separated string of values: >>> rec_id = ( \"start_str startdate experiment_id \" + \"investigator_id equipment_code\") >>> header . recording_id = rec_id Using EdfRecordingId: >>> rec_id = EdfRecordingId ( startdate , experiment_id , ... investigator_id , equipment_code ) >>> header . recording_id = rec_id","title":"recording_id()"},{"location":"api/headers/#edfrw.headers.EdfHeader.signals","text":"Get or set the list of signals in an EDF file. This attribute is a list of EdfSignal signal objects.","title":"signals()"},{"location":"api/headers/#edfrw.headers.EdfHeader.startdate","text":"Set or get the recording start date. Parameters: Name Type Description Default value str or datetime It must be either (a) a string \u2018yyyy-mm-dd\u2019, e.g. \u20182016-10-25\u2019, or (b) a string \u2018d.m.y\u2019 as required by EDF, e.g. \u201816.10.25\u2019, or (c) a datetime object required Returns: Name Type Description startdate datetime object","title":"startdate()"},{"location":"api/headers/#edfrw.headers.EdfHeader.starttime","text":"Get or set the recording start time. Parameters: Name Type Description Default value str or datetime It must be either (a) a string \u2018H.M.S\u2019 as required by EDF, e.g. \u201812.15.05\u2019, or (b) a string in standard format \u2018H:M:S\u2019, e.g. \u201812:15:05\u2019, or (b) a datetime object. required","title":"starttime()"},{"location":"api/headers/#edfrw.headers.EdfHeader.subject_id","text":"Get or set the subject (patient) ID record. The subject ID can be a single string with values [code, sex, dob, name] separated by spaces (as is the case when reading the patient ID from the header of and EDF file), or an object of class EdfSubjectId . Examples: Use a single string, values are space-separated. >>> header . subject_id = \"the_code X 1990-01-01 the_name\" or use EdfSubjectID >>> id = EdfSubjectID ( code , sex , dob , name ) >>> header . subject_id = id","title":"subject_id()"},{"location":"api/headers/#edfrw.headers.EdfRecordingId","text":"Recording identification. The \u2018local recording identification field\u2019 is a string of 80 characters in the header of a EDF file. It contains information about the start date, experiment ID, investigator ID, and equipment code, each of these separated by a space. This class handles that information. It is seldom useful on its own but rather as an attribute of class::Header . Attributes: Name Type Description equipment_code str experiment_id str investigator_id str startdate datetime . date The \u2018local recording identification field\u2019. The recording identification field forms part of the EDF header. All these subfields together will be concatenated (separated by spaces) to form one string which must not exceed 80 characters. Note that the text \u2018Startdate\u2019 is always prepended to this string, and this must betaken into account for the character count. Fields that are unknown (empty strings) will be replaced by an \u2018X\u2019 as per the EDF specification. Parameters: Name Type Description Default startdate str or datetime or None, default The start date. Expected to be: (a) a string in isoformat (\u2018yyyy-mm-dd\u2019), or (b) a datetime instance, as in e.g. datetime.now(), or (c) a date string with format \u2018%d-%b-%Y\u2019, as in e.g. \u201802-AUG-1951\u2019, which is the format required by EDF for this field, or (d) None, in which case the current date will be used None experiment_id str , default \u201cThe hospital administration code of the investigation, i.e. EEG number\u201d (Kemp, 2003) '' investigator_id str , default \u201cA code identifying the responsible investigator\u201d (Kemp, 2003) '' equipment_code str , default \u201cA code specifying the used equipment\u201d (Kemp, 2003) ''","title":"EdfRecordingId"},{"location":"api/headers/#edfrw.headers.EdfRecordingId.equipment_code","text":"Get or set the equipment code. Any spaces will be replaced by underscores.","title":"equipment_code()"},{"location":"api/headers/#edfrw.headers.EdfRecordingId.experiment_id","text":"Get or set the experiment ID. Any spaces will be replaced by underscores, as required by EDF.","title":"experiment_id()"},{"location":"api/headers/#edfrw.headers.EdfRecordingId.investigator_id","text":"Get or set the investigator ID. Any spaces will be replaced by underscores, as required by EDF.","title":"investigator_id()"},{"location":"api/headers/#edfrw.headers.EdfRecordingId.startdate","text":"Get or set the recording start date. To set the date, any of these values are acceptable: (a) a string in isoformat (\u2018yyyy-mm-dd\u2019), or (b) a datetime instance, as in e.g. datetime.now(), or (c) a date string with format \u2018%d-%b-%Y\u2019, which is the format required by EDF for this field. (d) None, in which case the current date will be used. In all cases startdate will be saved internally as a datetime object.","title":"startdate()"},{"location":"api/headers/#edfrw.headers.EdfRecordingId.to_str","text":"Return the recording identification as a single string. The local recording identification in an EDF file must be a string no longer than 80 characters. This function concatenates the recording attributes to create such a string. This is useful for making the full EDF header record. Returns: Name Type Description rec_id str A string containing the recording identification in the format specified by EDF.","title":"to_str()"},{"location":"api/headers/#edfrw.headers.EdfSignal","text":"Properties of a signal. These properties are stored in the header of an EDF file (after the first 256 bytes which contain the \u2018main\u2019 header). Each signal header is 256 bytes long. Attributes: Name Type Description digital_max int digital_min int gain number label str number_of_samples_in_data_record int physical_dim str physical_max number physical_min number prefiltering str reserved str sampling_freq number transducer_type str Examples: Example 1: A voltage signal digitised with a 12-bit ADC, single-ended, input range 0 to 5 V. Sampling rate (fs) is 30 Hz. saving_period_s is how often (in seconds) the data are saved to disk. >>> fs = 30 >>> signal = edfrw . EdfSignal ( label = 'ADC' , sampling_freq = fs , ... physical_dim = \"V\" , ... number_of_samples_in_data_record = saving_period_s * fs , ... physical_min = 0 , physical_max = 5 , ... digital_min = 0 , digital_max = 4095 ) Example 2: A voltage signal, digitised with a 16-bit ADC with input range -10 to 10 V. Sampling rate (fs) is 1000 Hz. >>> fs = 1000 >>> signal = edfrw . EdfSignal ( label = 'ADC' , sampling_freq = fs , ... number_of_samples_in_data_record = saving_period_s * fs , ... physical_dim = \"V\" , physical_min =- 10 , physical_max = 10 , ... digital_min =- 0x8000 , digital_max = 0x7fff ) Example 3: A digital signal as a boolean (off = 0, on = 1) >>> signal = edfrw . EdfSignal ( label = 'ON-OFF' , sampling_freq = fs , ... number_of_samples_in_data_record = saving_period_s * fs , ... physical_min = 0 , physical_max = 1 , digital_min = 0 , ... digital_max = 1 ) Properties of a signal in an EDF file. Parameters: Name Type Description Default label str , max . length '' transducer_type str of size 80, default The type of sensor used, e.g. \u2018thermistor\u2019 or \u2018Ag-AgCl electrode\u2019. '' physical_dim str , max . length The physical dimension. A string that must start with a prefix (e.g. \u2018u\u2019 for \u2018micro\u2019) followed by the basic dimension (e.g. \u2018V\u2019 for volts). Other examples of basic dimensions are \u2018K\u2019, \u2018degC\u2019 or \u2018degF\u2019 for temperature, and \u2018%\u2019 for SaO2. Powers are denoted by \u2018^\u2019, as in \u2018V^2/Hz\u2019. An empty string represents an uncalibrated signal. For standards on labels and units, see http://www.edfplus.info/specs/edftexts.html '' physical_min number , default -32768 physical_max number , default The physical minimum and maximum should correspond to the digital extremes digital_min and digital_max and be expressed in the physical dimension physical_dim . The values of physical_min and physical_max must be different. 32767 digital_min number , default -32768 digital_max number , default \u201cThe digital minimum and maximum of each signal should specify the extreme values that can occur in the data records. These often are the extreme output values of the A/D converter.\u201d (Kemp et al. 1992). digital_max must be larger than digital_min . Together, the two digital_ and the two physical_ values specify the offset and the amplification of the signal. 32767 prefiltering str , max . length Specifies if this signal was filtered; e.g. for high-pass, low-pass, or notch filtering, \u2018HP:0.1Hz\u2019, \u2018LP:75Hz\u2019, \u2018N:50Hz\u2019 '' number_of_samples_in_data_record integer , default The number of 16-bit integers that this signal occupies 0 sampling_freq number , default The sampling frequency. This subfield is not part of the EDF specification. It is added for convenience. 0","title":"EdfSignal"},{"location":"api/headers/#edfrw.headers.EdfSignal--notes","text":"Use only ascii characters. The data in EDF files are saved as two\u2019s complement, 16-bit integers. Thus, the range between digital_min and digital_max must not exceed 2**16 - 1 = 65535.","title":"Notes"},{"location":"api/headers/#edfrw.headers.EdfSignal.dig_to_phys","text":"Convert a digital value to a physical value. Parameters: Name Type Description Default value uint16 or array of uint16_t A digital value to convert. EDF digital values are always unsigned, 16-bit integers. required Returns: Name Type Description phys float or array of float The corresponding physical value.","title":"dig_to_phys()"},{"location":"api/headers/#edfrw.headers.EdfSignal.dig_to_phys--notes","text":"These equations follow those used in EDFBrowser to convert from EDF to ascii ( ascii_export.cpp )","title":"Notes"},{"location":"api/headers/#edfrw.headers.EdfSignal.digital_max","text":"Get or set the signal\u2019s digital maximum value.","title":"digital_max()"},{"location":"api/headers/#edfrw.headers.EdfSignal.digital_min","text":"Get or set the signal\u2019s digital minimum value.","title":"digital_min()"},{"location":"api/headers/#edfrw.headers.EdfSignal.gain","text":"Get the signal gain. The gain maps physical to digital dimensions. This property is calculated automatically whenever the digital or physical min/max values are set.","title":"gain()"},{"location":"api/headers/#edfrw.headers.EdfSignal.label","text":"Get or set the signal label.","title":"label()"},{"location":"api/headers/#edfrw.headers.EdfSignal.number_of_samples_in_data_record","text":"Get or set the number of samples in each data record.","title":"number_of_samples_in_data_record()"},{"location":"api/headers/#edfrw.headers.EdfSignal.phys_to_dig","text":"Convert a physical value to a digital value. Parameters: Name Type Description Default value float or array of floats The physical value(s) to convert required Returns: Name Type Description dig uint16_t or array of uint16_t The digital value","title":"phys_to_dig()"},{"location":"api/headers/#edfrw.headers.EdfSignal.phys_to_dig--notes","text":"Follows the equation of a straight line (point-slope form): y = m * (x - x1) + y1 x = (y - y1)/m + x1","title":"Notes"},{"location":"api/headers/#edfrw.headers.EdfSignal.physical_dim","text":"Get or set the signal\u2019s physical dimension.","title":"physical_dim()"},{"location":"api/headers/#edfrw.headers.EdfSignal.physical_max","text":"Get or set the signal\u2019s physical maximum.","title":"physical_max()"},{"location":"api/headers/#edfrw.headers.EdfSignal.physical_min","text":"Get or set the signal\u2019s physical minimum.","title":"physical_min()"},{"location":"api/headers/#edfrw.headers.EdfSignal.prefiltering","text":"Get or set the signal\u2019s prefiltering information. Examples: If the signal was low-pass filtered with a 10 Hz cut-off, >>> signal . prefiltering = \"LP:10Hz\"","title":"prefiltering()"},{"location":"api/headers/#edfrw.headers.EdfSignal.transducer_type","text":"Get or set the transducer type.","title":"transducer_type()"},{"location":"api/headers/#edfrw.headers.EdfSubjectId","text":"Subject (patient) identification. The subject (patient) identification is a string (80 characters long) in the header of a EDF file than contains information about the patient\u2019s code, name, sex, and date of birth. This class handles that information. It is seldom useful on its own but rather as an attribute of class::Header . Attributes: Name Type Description code str Patient code sex str Patient sex dob datetime . date Patient date of birth name str Patient name Properties that identify the subject. Parameters: Name Type Description Default code str , default Patient code '' sex str '' dob str or datetime, default Date of birth. It must be entered as: (a) a string in EDF format \u2018dd-MMM-yy\u2019, as in \u201830-DEC-1999\u2019; (b) a string in iso format \u2018yyyy-mm-dd\u2019, as in \u20181999-12-30\u2019; or (c) a datetime object. '' name str , default The patient\u2019s name '' Any field that is not known can be entered as \u2018X\u2019 (as per the EDF standard) or as an empty string \u2018\u2019.","title":"EdfSubjectId"},{"location":"api/headers/#edfrw.headers.EdfSubjectId.code","text":"Get or set the patient\u2019s code.","title":"code()"},{"location":"api/headers/#edfrw.headers.EdfSubjectId.dob","text":"Get or set the date of birth (DOB). If DOB is not known it must be an empty string \u2018\u2019 or \u2018X\u2019. If it is known, it must be entered as (a) a string in EDF format \u2018dd-MMM-yy\u2019, as in \u201830-DEC-1999\u2019; (b) a string in iso format \u2018yyyy-mm-dd\u2019, as in \u20181999-12-30\u2019; or (c) a datetime object. In any case the date will be stored as a datetime.date object.","title":"dob()"},{"location":"api/headers/#edfrw.headers.EdfSubjectId.name","text":"Get or set the patient\u2019s name.","title":"name()"},{"location":"api/headers/#edfrw.headers.EdfSubjectId.sex","text":"Get or set the patient\u2019s sex.","title":"sex()"},{"location":"api/headers/#edfrw.headers.EdfSubjectId.to_str","text":"Return patient ID record as a single string. The patient identification record in an EDF file must be a string no longer than 80 characters. This function concatenates the patient attributes to create such a string. This is useful for making the full EDF header record. Returns: Name Type Description patient_id str A string containing patient ID in the format specified by EDF.","title":"to_str()"},{"location":"api/reader/","text":"edfrw.reader Tools for reading data from European Data Format (EDF) files. EdfReader ( filename ) Bases: object Open an EDF file for reading. Attributes: Name Type Description header object of `class::EdfHeader` EDF file header. filename str Path to edf file. signals list List of signals in EDF file. duration_s number Duration of the recording in seconds. Notes This class currently only works for reading EDF files. Data from EDF+C files can also be read but the \u201cEDF Annotations\u201d signal will not be properly parsed. EDF+D files are not supported. Open and EDF file for reading. Parameters: Name Type Description Default filename str Path to the EDF file. required close () Close the file. read_record ( rec_number ) Return data from one record. Parameters: Name Type Description Default rec_number integer Record number to read data from (index starts from 0). required Returns: Name Type Description samples array of int16 Data samples in record, in the original order and format as that stored in the EDF file (i.e. all samples from signal 0 followed by all samples from signal 1, etc.) read_signal ( signal , from_second = 0 , to_second = np . Inf ) Read a signal from an EDF file. Parameters: Name Type Description Default signal integer or string Signal to read. If an integer, it is the signal index (starting from 0); if a string it is the name (label) of the signal. required from_second numeric , default Time in seconds to read data from. 0 to_second numeric , default Time in seconds to read data to. np.Inf Returns: Type Description time , samples Time (in seconds) and signal data samples. Examples: >>> edffile = EdfReader ( \"myfile.edf\" ) Assuming this file has a signal labelled \u201cADC\u201d, read that signal from time 20 to time 750 seconds. >>> time , samples = edffile . read_signal ( \"ADC\" , 20 , 750 ) read_signal_from_record ( sig_number , rec_number ) Read a signal in a data record. Parameters: Name Type Description Default sig_number int Number of the signal to read (starts from 0). required rec_number int Record number (starts from 0). required Returns: Type Description time , samples Time in seconds and signal data samples. header_fromfile ( filename ) Read the header from an EDF file. Parameters: Name Type Description Default filename str Path to the EDF file required Returns: Name Type Description header object of","title":"Reader"},{"location":"api/reader/#edfrw.reader","text":"Tools for reading data from European Data Format (EDF) files.","title":"reader"},{"location":"api/reader/#edfrw.reader.EdfReader","text":"Bases: object Open an EDF file for reading. Attributes: Name Type Description header object of `class::EdfHeader` EDF file header. filename str Path to edf file. signals list List of signals in EDF file. duration_s number Duration of the recording in seconds.","title":"EdfReader"},{"location":"api/reader/#edfrw.reader.EdfReader--notes","text":"This class currently only works for reading EDF files. Data from EDF+C files can also be read but the \u201cEDF Annotations\u201d signal will not be properly parsed. EDF+D files are not supported. Open and EDF file for reading. Parameters: Name Type Description Default filename str Path to the EDF file. required","title":"Notes"},{"location":"api/reader/#edfrw.reader.EdfReader.close","text":"Close the file.","title":"close()"},{"location":"api/reader/#edfrw.reader.EdfReader.read_record","text":"Return data from one record. Parameters: Name Type Description Default rec_number integer Record number to read data from (index starts from 0). required Returns: Name Type Description samples array of int16 Data samples in record, in the original order and format as that stored in the EDF file (i.e. all samples from signal 0 followed by all samples from signal 1, etc.)","title":"read_record()"},{"location":"api/reader/#edfrw.reader.EdfReader.read_signal","text":"Read a signal from an EDF file. Parameters: Name Type Description Default signal integer or string Signal to read. If an integer, it is the signal index (starting from 0); if a string it is the name (label) of the signal. required from_second numeric , default Time in seconds to read data from. 0 to_second numeric , default Time in seconds to read data to. np.Inf Returns: Type Description time , samples Time (in seconds) and signal data samples. Examples: >>> edffile = EdfReader ( \"myfile.edf\" ) Assuming this file has a signal labelled \u201cADC\u201d, read that signal from time 20 to time 750 seconds. >>> time , samples = edffile . read_signal ( \"ADC\" , 20 , 750 )","title":"read_signal()"},{"location":"api/reader/#edfrw.reader.EdfReader.read_signal_from_record","text":"Read a signal in a data record. Parameters: Name Type Description Default sig_number int Number of the signal to read (starts from 0). required rec_number int Record number (starts from 0). required Returns: Type Description time , samples Time in seconds and signal data samples.","title":"read_signal_from_record()"},{"location":"api/reader/#edfrw.reader.header_fromfile","text":"Read the header from an EDF file. Parameters: Name Type Description Default filename str Path to the EDF file required Returns: Name Type Description header object of","title":"header_fromfile()"},{"location":"api/writer/","text":"edfrw.writer Write data to files in European Data Format (EDF). EdfWriter ( filename , header , saving_period_s ) Bases: object Open an EDF for writing. Attributes: Name Type Description filename str EDF file name. header object of `class::EdfHeader` File header. saving_period_s int How often to write data to the EDF file. closed bool Whether the file has been closed. Create and open an EDF file for writing. Parameters: Name Type Description Default filename str EDF file name. required header instance of The file header. required saving_period_s integer How often (in seconds) will the data be saved to disk? This value sets EDF header\u2019s duration_of_data_record , which is the duration in seconds of one data record. From the specification: \u201cThe duration of each data record is recommended to be a whole number of seconds and its size (number of bytes) is recommended not to exceed 61440. Only if a 1s data record exceeds this size limit, the duration is recommended to be smaller than 1s (e.g. 0.01).\u201d required close () Close the EDF file update_number_of_records () Update the number of data records in the file header. Writes to the header the most recent value of \u2018number_of_data_records\u2019 (referred to as \u2018nr\u2019 in the EDF specification). By definition, this value is 8-bits long and it starts at position 236 in the header. write_data_record ( buffer ) Write one data record. Parameters: Name Type Description Default buffer uint16 The data to be save to disk. It must be an unsigned 16-bit integer, two-complement values, as required by the EDF file format specification. required Notes Signals are allowed to be acquired at different sampling rates. The data are saved in data blocks (named \u2018data records\u2019 in the specification). The total number of samples in the block is thus determined by adding the sizes of the individual signals ( signal.number_of_samples_in_data_record ). Each data block holds all data acquired during a time interval of header.duration_of_data_record seconds, and the total number of data records in the file are header.number_of_data_records . Thus, to write a data block (data record), the data must be the concatenation of samples acquired during the period of time duration_of_data_record first all samples from signal 0, then signal 1, etc: signal_0.samples[sig_0_number_of_samples_in_data_record] signal_1.samples[sig_1_number_of_samples_in_data_record] write_header () Write the EDF header to the current file. Packs the header record attributes in the format required by EDF and writes these values at the beginning of the current file.","title":"Writer"},{"location":"api/writer/#edfrw.writer","text":"Write data to files in European Data Format (EDF).","title":"writer"},{"location":"api/writer/#edfrw.writer.EdfWriter","text":"Bases: object Open an EDF for writing. Attributes: Name Type Description filename str EDF file name. header object of `class::EdfHeader` File header. saving_period_s int How often to write data to the EDF file. closed bool Whether the file has been closed. Create and open an EDF file for writing. Parameters: Name Type Description Default filename str EDF file name. required header instance of The file header. required saving_period_s integer How often (in seconds) will the data be saved to disk? This value sets EDF header\u2019s duration_of_data_record , which is the duration in seconds of one data record. From the specification: \u201cThe duration of each data record is recommended to be a whole number of seconds and its size (number of bytes) is recommended not to exceed 61440. Only if a 1s data record exceeds this size limit, the duration is recommended to be smaller than 1s (e.g. 0.01).\u201d required","title":"EdfWriter"},{"location":"api/writer/#edfrw.writer.EdfWriter.close","text":"Close the EDF file","title":"close()"},{"location":"api/writer/#edfrw.writer.EdfWriter.update_number_of_records","text":"Update the number of data records in the file header. Writes to the header the most recent value of \u2018number_of_data_records\u2019 (referred to as \u2018nr\u2019 in the EDF specification). By definition, this value is 8-bits long and it starts at position 236 in the header.","title":"update_number_of_records()"},{"location":"api/writer/#edfrw.writer.EdfWriter.write_data_record","text":"Write one data record. Parameters: Name Type Description Default buffer uint16 The data to be save to disk. It must be an unsigned 16-bit integer, two-complement values, as required by the EDF file format specification. required","title":"write_data_record()"},{"location":"api/writer/#edfrw.writer.EdfWriter.write_data_record--notes","text":"Signals are allowed to be acquired at different sampling rates. The data are saved in data blocks (named \u2018data records\u2019 in the specification). The total number of samples in the block is thus determined by adding the sizes of the individual signals ( signal.number_of_samples_in_data_record ). Each data block holds all data acquired during a time interval of header.duration_of_data_record seconds, and the total number of data records in the file are header.number_of_data_records . Thus, to write a data block (data record), the data must be the concatenation of samples acquired during the period of time duration_of_data_record first all samples from signal 0, then signal 1, etc: signal_0.samples[sig_0_number_of_samples_in_data_record] signal_1.samples[sig_1_number_of_samples_in_data_record]","title":"Notes"},{"location":"api/writer/#edfrw.writer.EdfWriter.write_header","text":"Write the EDF header to the current file. Packs the header record attributes in the format required by EDF and writes these values at the beginning of the current file.","title":"write_header()"},{"location":"usage/reading/","text":"Reading data from an EDF file Simple use To read data from and EFD file, simply open the file and read the signal of interest. To illustrate this, a sample EDF test file (\u201ctest_generator_2\u201d) was downloaded from EDFBrowser testfiles , and Python was run from an interactive ipython shell with matplotlib for plotting. # Import the relevant edfrw function. from edfrw import open_edf # Open the file in reading (default) mode. >>> edf = open_edf('test_generator_2.edf') # Use `print` to display a summary of the file. >>> print(edf) Subject ID: X X X X Recording ID: Startdate 10-Dec-2009 X X test_generator Start date: 2009-12-10 Start time: 12:44:02 Duration: 0:10:00 Nr of data records: 600 Dur of data record: 1.0 Nr of signals: 12 Signal labels: ['squarewave', 'ramp', 'pulse', 'ECG', 'noise', 'sine 1 Hz', 'sine 8 Hz', 'sine 8.5 Hz', 'sine 15 Hz', 'sine 17 Hz', 'sine 50 Hz', 'EDF Annotations'] # `print` also works on the record header. Try e.g. # print(f.header) # Read and plot the first 5 seconds of data stored in the signal # \"sine 1 Hz\". >>> x, y = edf.read_signal(\"sine 1 Hz\", from_second=0, to_second=5) >>> plot(x, y) # Close the file if it is no longer required. >>> edf.close() Instead of using the signal name, it is possible to refer to a signal by its index (starting from 0). Thus, to read a few seconds of signal \u201cramp\u201d, which is in position 1: >>> edf = open_edf('test_generator_2.edf') >>> x, y = edf.read_signal(1, from_second=10.5, to_second=12.2) >>> edf.close() >>> plot(x, y) Signal information EDF signals are stored in a list in the main edfrw file: >>> edf = open_edf('test_generator_2.edf') >>> edf.signals [<EDFSignal squarewave>, <EDFSignal ramp>, <EDFSignal pulse>, <EDFSignal ECG>, <EDFSignal noise>, <EDFSignal sine 1 Hz>, <EDFSignal sine 8 Hz>, <EDFSignal sine 8.5 Hz>, <EDFSignal sine 15 Hz>, <EDFSignal sine 17 Hz>, <EDFSignal sine 50 Hz>, <EDFSignal EDF Annotations>] This can be used to inspect signals individually. For example, to see the properties of the first signal (i.e. signal 0), >>> sig = edf.signals[0] >>> print(sig) label squarewave transducer_type physical_dim uV physical_min -1000.0 physical_max 1000.0 digital_min -32768 digital_max 32767 prefiltering number_of_samples_in_data_record 200 reserved sampling_freq 200.0 gain 0.030518043793392843 Additional functions The module edfrw.reader provides additional functions for reading EDF data. These are probably most useful for larger applications where it may be convenient to read raw data from each block (i.e. data record), or to iterate along data blocks, etc. The function read_record reads data from a given record (indexed from 0) and returns it raw, as stored by edf. The recipient then must unpack and convert the data samples as required. >>> edf = open_edf('test_generator_2.edf') >>> samples = edf.read_record(0) >>> size(samples) 4502 >>> samples[:10] b'\\xcc\\x0c\\xcc\\x0c\\xcc\\x0c\\xcc\\x0c\\xcc\\x0c' >>> type(samples) bytes A related function, read_signal_from_record also reads data from only one edf data block (i.e. a record), but unpacks the data and converts to physical values. It may be used as the building block for larger EDF reading applications. Limitations Currently, edfrw only works for reading EDF files. Data from EDF+C (i.e. continuous recording with annotations) files can also be read but the \u201cEDF Annotations\u201d signal will not be properly parsed. EDF+D files (i.e. interrupted recording) are not supported.","title":"Reading data"},{"location":"usage/reading/#reading-data-from-an-edf-file","text":"","title":"Reading data from an EDF file"},{"location":"usage/reading/#simple-use","text":"To read data from and EFD file, simply open the file and read the signal of interest. To illustrate this, a sample EDF test file (\u201ctest_generator_2\u201d) was downloaded from EDFBrowser testfiles , and Python was run from an interactive ipython shell with matplotlib for plotting. # Import the relevant edfrw function. from edfrw import open_edf # Open the file in reading (default) mode. >>> edf = open_edf('test_generator_2.edf') # Use `print` to display a summary of the file. >>> print(edf) Subject ID: X X X X Recording ID: Startdate 10-Dec-2009 X X test_generator Start date: 2009-12-10 Start time: 12:44:02 Duration: 0:10:00 Nr of data records: 600 Dur of data record: 1.0 Nr of signals: 12 Signal labels: ['squarewave', 'ramp', 'pulse', 'ECG', 'noise', 'sine 1 Hz', 'sine 8 Hz', 'sine 8.5 Hz', 'sine 15 Hz', 'sine 17 Hz', 'sine 50 Hz', 'EDF Annotations'] # `print` also works on the record header. Try e.g. # print(f.header) # Read and plot the first 5 seconds of data stored in the signal # \"sine 1 Hz\". >>> x, y = edf.read_signal(\"sine 1 Hz\", from_second=0, to_second=5) >>> plot(x, y) # Close the file if it is no longer required. >>> edf.close() Instead of using the signal name, it is possible to refer to a signal by its index (starting from 0). Thus, to read a few seconds of signal \u201cramp\u201d, which is in position 1: >>> edf = open_edf('test_generator_2.edf') >>> x, y = edf.read_signal(1, from_second=10.5, to_second=12.2) >>> edf.close() >>> plot(x, y)","title":"Simple use"},{"location":"usage/reading/#signal-information","text":"EDF signals are stored in a list in the main edfrw file: >>> edf = open_edf('test_generator_2.edf') >>> edf.signals [<EDFSignal squarewave>, <EDFSignal ramp>, <EDFSignal pulse>, <EDFSignal ECG>, <EDFSignal noise>, <EDFSignal sine 1 Hz>, <EDFSignal sine 8 Hz>, <EDFSignal sine 8.5 Hz>, <EDFSignal sine 15 Hz>, <EDFSignal sine 17 Hz>, <EDFSignal sine 50 Hz>, <EDFSignal EDF Annotations>] This can be used to inspect signals individually. For example, to see the properties of the first signal (i.e. signal 0), >>> sig = edf.signals[0] >>> print(sig) label squarewave transducer_type physical_dim uV physical_min -1000.0 physical_max 1000.0 digital_min -32768 digital_max 32767 prefiltering number_of_samples_in_data_record 200 reserved sampling_freq 200.0 gain 0.030518043793392843","title":"Signal information"},{"location":"usage/reading/#additional-functions","text":"The module edfrw.reader provides additional functions for reading EDF data. These are probably most useful for larger applications where it may be convenient to read raw data from each block (i.e. data record), or to iterate along data blocks, etc. The function read_record reads data from a given record (indexed from 0) and returns it raw, as stored by edf. The recipient then must unpack and convert the data samples as required. >>> edf = open_edf('test_generator_2.edf') >>> samples = edf.read_record(0) >>> size(samples) 4502 >>> samples[:10] b'\\xcc\\x0c\\xcc\\x0c\\xcc\\x0c\\xcc\\x0c\\xcc\\x0c' >>> type(samples) bytes A related function, read_signal_from_record also reads data from only one edf data block (i.e. a record), but unpacks the data and converts to physical values. It may be used as the building block for larger EDF reading applications.","title":"Additional functions"},{"location":"usage/reading/#limitations","text":"Currently, edfrw only works for reading EDF files. Data from EDF+C (i.e. continuous recording with annotations) files can also be read but the \u201cEDF Annotations\u201d signal will not be properly parsed. EDF+D files (i.e. interrupted recording) are not supported.","title":"Limitations"},{"location":"usage/specifications/","text":"Overview of EDF specifications This section presents a brief overview of the EDF specifications. This overview should help understand how to use the various functions and classes in this edfrw library. The full EDF specifications can be found here EDF files consist of a header (ascii) that describes the contents of the file and the experimental settings. The data (int16) are stored after the header in data records. The Header The first 256 bytes in an EDF file are the header, which contains information about the patient, date and time of data acquisition, etc. This is followed by another 256 bytes for each signal acquired. Signal header(s) contain the details about the name of the signals, the hardware used, and values to allow the transformation of raw (int16) data values into physical values (e.g. volts). Thus, the length of the full header (i.e. the \u2018header record\u2019) equals 256 + (number_of_signals * 256). The header record is ascii only, and contains the following fields: Header record Field Size Position Notes version 8 0 [1] patient_id 80 8 [2] recording_id 80 88 [3] startdate 8 168 dd.mm.yy starttime 8 176 hh.mm.ss number_of_bytes_in_header 8 184 reserved 44 192 [4] number_of_data_records 8 236 \u2018nr\u2019 duration_of_data_record 8 244 in seconds number_of_signals 4 252 \u2018ns\u2019 (total) 256 Notes \u2018version\u2019 is always \u20180\u2019. \u2018patient_id\u2019 must consist of 4 space-separated strings: Code Sex DOB Name, where Code is the patient code Sex is M, F, or X DOB is date of birth in format dd-MMM-yyyy Name is patient\u2019s name (If a subfield is not known, replace with an X) \u2018recording_id\u2019 is a string 'Startdate dd-MMM-yyyy ExpID InvestigID Equipment' , where The text \u201cStartdate\u201d dd-MMM-yyyy, the actual start date ExpID, code of the experiment/investigation InvestigID, code of responsible investigator Equipment, code of equipment used Additional optional subfields may follow the ones above Example: \u2018Startdate 02-MAR-2002 PSG-1234=2002 NN Telemetry03\u2019 \u2018reserved\u2019: empty for EDF; \u2018EDF+C\u2019 for continuous recording; \u2018EDF+D\u2019 if the recording is interrupted. Signal record After the main header there is information about each signal acquired. This information forms part of the \u2018header record\u2019 in the specifications but it is helpful to look at it separately: Field Size Position Notes label 16 0 transducer 80 16 [1] physical_dim 8 96 [2] physical_min 8 104 physical_max 8 112 digital_min 8 120 [3] digital_max 8 128 [3] prefiltering 80 136 [4] number_of_samples 8 216 reserved 32 224 (total) 256 Notes \u2018transducer\u2019 type, e.g. \u2018thermistor\u2019. \u2018physical_dim\u2019 (physical dimension, e.g. \u2018uV\u2019) must start with a prefix (in this example u) followed by the basic dimension (in this example V). For full details see the EDF full specifications . The digital range must be somewhere between -32768 and 32767 (because data samples are 16-bit signed integers). \u2018prefiltering\u2019: e.g. for high-pass, low-pass and notch filters: \u2018HP:0.1 Hz LP:75 Hz N:50 Hz\u2019. Thus, after the main header there are 256 bytes for each signal acquired. It is worth noting that each field in the signal record holds the values for all signals (rather than the header storing one full signal record, then a second full signal record, etc). That is, if e.g. two signals are acquired, then there will be two consecutive \u2018label\u2019 fields (16 + 16 bytes), then two consecutive \u2018transducer\u2019 fields (80 + 80 bytes), then two \u2018physical_dim\u2019 fields (8 + 8 bytes), etc. Data record Data records follow after the header record. Here, data samples (of type int16) are stored in blocks (the data record ). Each block contains the samples acquired during a period of time specified in the header as \u2018duration_of_data_record\u2019, and the total number of blocks in the file are \u2018number_of_data_records\u2019. Note that EDF allows the acquisition of signals at different sampling rates; the number of samples per signal in each data block is in the signal header (\u2018number_of_samples_in_data_record\u2019). For example, two signals signal_A and signal_B are acquired at 100 Hz and 5 Hz respectively. The data are saved every 20 seconds (i.e. duration_of_data_record = 20 ). Thus, one block of data (a data record) will consist of 2000 samples (number_of_samples_in_data_record = 100 Hz times 20 seconds = 2000) from signal_A followed by 100 samples (number_of_samples_in_data_record = 5 Hz times 20 seconds = 100) from signal_B . If the header indicates that there are 70 such blocks ( number_of_data_records = 70 ), then the total duration of the recording would be 70 x 20 = 1400 seconds ( number_of_data_records x duration_of_data_record ). Converting digital samples to physical dimensions Data samples are stored as 16-bit (2-byte signed, little endian, two\u2019s complement) integers. An easy way to convert those values to their physical equivalent is by using the equation for a straight line with the signal information stored in the EdfSignal record. ( Note that this conversion is done automatically by the function edfrw.headers.EdfSignal.dig_to_phys so typically it is not necessary to worry about this. The procedure is documented here for completeness.) The slope m (or gain) of a straight line is the ratio of change in y by change in x : m = (y1 - y0) / (x1 - x0) and if the slope m and the intercept b are known, then the line can be described by: y = m * (x + b) It can be seen that the raw int16 data values stored in an EDF file correspond to x in that equation, that the physical values that we are looking for are y , and that these two are related by the parameters set in the EdfSignal record. The slope can be calculated as: m = (y1 - y0) / (x1 - x0) m = (physical_max - physical_min) / (digital_max - digital_min) and the offset (or intercept) b will be the physical_min value. From these the physical values can be obtained using the line equation: b = offset = physical_max / m - digital_max y = m * (x + b) physical_value = m * (digital_value + b) Example 1 An EDF file contains data obtained after measuring voltage with the adc from the mbed LPC1768. The native EDF data are stored as 2-byte integer digital samples. The mbed has an 12-bit adc, so its digital range is from 0 to 4095, and the reference voltage in the mbed is 3.3 V, so the physical range that the adc can measure is 0 V to 3.3 V. Thus, the header record in such EDF file would be: physical_dim = 'V' physical_min = 0 physical_max = 3.3 digital_min = 0 digital_max = 4095 These parameters are used to calculate the gain m (slope): m = (y1 - y0) / (x1 - x0) m = (physical_max - physical_min) / (digital_max - digital_min) m = (3.3 - 0) / (4095 - 0) m = 0.0008 b = physical_max / m - digital_max b = 3.3 / 0.0008 - 4095 b = 0.5 and with that the physical values (voltage): physical_value = m * (digital_value + b) physical_value = 0.0008 * (digital_value + 0.5) digital value of 2048 will represent 0.0008 * (2048 + 0) = 1.65 volts, as expected. Example 2 EEG data are acquired using a commercial system. The manufacturer explains in the documentation that the analog outputs from their hardware are signals that range between 0 and 5 volts, and are centred at 2.048 V, so: physical_dim = 'V' physical_min = 0 - 2.048 = -2.048 physical_max = 5 - 2.048 = 2.952 If these signals were acquired with a 14-bit ADC, then: digital_min = 0 digital_max = 2**14 - 1 = 16383 and thus: m = (physical_max - physical_min) / (digital_max - digital_min) m = (2.952 + 2.048) / (16383 - 0) m = 5 / 16383 = 0.00031 b = offset = physical_max / m - digital_max = -23093.4768 y = m * x + b physical_value = 0.00031 * (digital_value + -23093.4768)","title":"The EDF specification"},{"location":"usage/specifications/#overview-of-edf-specifications","text":"This section presents a brief overview of the EDF specifications. This overview should help understand how to use the various functions and classes in this edfrw library. The full EDF specifications can be found here EDF files consist of a header (ascii) that describes the contents of the file and the experimental settings. The data (int16) are stored after the header in data records.","title":"Overview of EDF specifications"},{"location":"usage/specifications/#the-header","text":"The first 256 bytes in an EDF file are the header, which contains information about the patient, date and time of data acquisition, etc. This is followed by another 256 bytes for each signal acquired. Signal header(s) contain the details about the name of the signals, the hardware used, and values to allow the transformation of raw (int16) data values into physical values (e.g. volts). Thus, the length of the full header (i.e. the \u2018header record\u2019) equals 256 + (number_of_signals * 256). The header record is ascii only, and contains the following fields:","title":"The Header"},{"location":"usage/specifications/#header-record","text":"Field Size Position Notes version 8 0 [1] patient_id 80 8 [2] recording_id 80 88 [3] startdate 8 168 dd.mm.yy starttime 8 176 hh.mm.ss number_of_bytes_in_header 8 184 reserved 44 192 [4] number_of_data_records 8 236 \u2018nr\u2019 duration_of_data_record 8 244 in seconds number_of_signals 4 252 \u2018ns\u2019 (total) 256 Notes \u2018version\u2019 is always \u20180\u2019. \u2018patient_id\u2019 must consist of 4 space-separated strings: Code Sex DOB Name, where Code is the patient code Sex is M, F, or X DOB is date of birth in format dd-MMM-yyyy Name is patient\u2019s name (If a subfield is not known, replace with an X) \u2018recording_id\u2019 is a string 'Startdate dd-MMM-yyyy ExpID InvestigID Equipment' , where The text \u201cStartdate\u201d dd-MMM-yyyy, the actual start date ExpID, code of the experiment/investigation InvestigID, code of responsible investigator Equipment, code of equipment used Additional optional subfields may follow the ones above Example: \u2018Startdate 02-MAR-2002 PSG-1234=2002 NN Telemetry03\u2019 \u2018reserved\u2019: empty for EDF; \u2018EDF+C\u2019 for continuous recording; \u2018EDF+D\u2019 if the recording is interrupted.","title":"Header record"},{"location":"usage/specifications/#signal-record","text":"After the main header there is information about each signal acquired. This information forms part of the \u2018header record\u2019 in the specifications but it is helpful to look at it separately: Field Size Position Notes label 16 0 transducer 80 16 [1] physical_dim 8 96 [2] physical_min 8 104 physical_max 8 112 digital_min 8 120 [3] digital_max 8 128 [3] prefiltering 80 136 [4] number_of_samples 8 216 reserved 32 224 (total) 256 Notes \u2018transducer\u2019 type, e.g. \u2018thermistor\u2019. \u2018physical_dim\u2019 (physical dimension, e.g. \u2018uV\u2019) must start with a prefix (in this example u) followed by the basic dimension (in this example V). For full details see the EDF full specifications . The digital range must be somewhere between -32768 and 32767 (because data samples are 16-bit signed integers). \u2018prefiltering\u2019: e.g. for high-pass, low-pass and notch filters: \u2018HP:0.1 Hz LP:75 Hz N:50 Hz\u2019. Thus, after the main header there are 256 bytes for each signal acquired. It is worth noting that each field in the signal record holds the values for all signals (rather than the header storing one full signal record, then a second full signal record, etc). That is, if e.g. two signals are acquired, then there will be two consecutive \u2018label\u2019 fields (16 + 16 bytes), then two consecutive \u2018transducer\u2019 fields (80 + 80 bytes), then two \u2018physical_dim\u2019 fields (8 + 8 bytes), etc.","title":"Signal record"},{"location":"usage/specifications/#data-record","text":"Data records follow after the header record. Here, data samples (of type int16) are stored in blocks (the data record ). Each block contains the samples acquired during a period of time specified in the header as \u2018duration_of_data_record\u2019, and the total number of blocks in the file are \u2018number_of_data_records\u2019. Note that EDF allows the acquisition of signals at different sampling rates; the number of samples per signal in each data block is in the signal header (\u2018number_of_samples_in_data_record\u2019). For example, two signals signal_A and signal_B are acquired at 100 Hz and 5 Hz respectively. The data are saved every 20 seconds (i.e. duration_of_data_record = 20 ). Thus, one block of data (a data record) will consist of 2000 samples (number_of_samples_in_data_record = 100 Hz times 20 seconds = 2000) from signal_A followed by 100 samples (number_of_samples_in_data_record = 5 Hz times 20 seconds = 100) from signal_B . If the header indicates that there are 70 such blocks ( number_of_data_records = 70 ), then the total duration of the recording would be 70 x 20 = 1400 seconds ( number_of_data_records x duration_of_data_record ).","title":"Data record"},{"location":"usage/specifications/#converting-digital-samples-to-physical-dimensions","text":"Data samples are stored as 16-bit (2-byte signed, little endian, two\u2019s complement) integers. An easy way to convert those values to their physical equivalent is by using the equation for a straight line with the signal information stored in the EdfSignal record. ( Note that this conversion is done automatically by the function edfrw.headers.EdfSignal.dig_to_phys so typically it is not necessary to worry about this. The procedure is documented here for completeness.) The slope m (or gain) of a straight line is the ratio of change in y by change in x : m = (y1 - y0) / (x1 - x0) and if the slope m and the intercept b are known, then the line can be described by: y = m * (x + b) It can be seen that the raw int16 data values stored in an EDF file correspond to x in that equation, that the physical values that we are looking for are y , and that these two are related by the parameters set in the EdfSignal record. The slope can be calculated as: m = (y1 - y0) / (x1 - x0) m = (physical_max - physical_min) / (digital_max - digital_min) and the offset (or intercept) b will be the physical_min value. From these the physical values can be obtained using the line equation: b = offset = physical_max / m - digital_max y = m * (x + b) physical_value = m * (digital_value + b)","title":"Converting digital samples to physical dimensions"},{"location":"usage/specifications/#example-1","text":"An EDF file contains data obtained after measuring voltage with the adc from the mbed LPC1768. The native EDF data are stored as 2-byte integer digital samples. The mbed has an 12-bit adc, so its digital range is from 0 to 4095, and the reference voltage in the mbed is 3.3 V, so the physical range that the adc can measure is 0 V to 3.3 V. Thus, the header record in such EDF file would be: physical_dim = 'V' physical_min = 0 physical_max = 3.3 digital_min = 0 digital_max = 4095 These parameters are used to calculate the gain m (slope): m = (y1 - y0) / (x1 - x0) m = (physical_max - physical_min) / (digital_max - digital_min) m = (3.3 - 0) / (4095 - 0) m = 0.0008 b = physical_max / m - digital_max b = 3.3 / 0.0008 - 4095 b = 0.5 and with that the physical values (voltage): physical_value = m * (digital_value + b) physical_value = 0.0008 * (digital_value + 0.5) digital value of 2048 will represent 0.0008 * (2048 + 0) = 1.65 volts, as expected.","title":"Example 1"},{"location":"usage/specifications/#example-2","text":"EEG data are acquired using a commercial system. The manufacturer explains in the documentation that the analog outputs from their hardware are signals that range between 0 and 5 volts, and are centred at 2.048 V, so: physical_dim = 'V' physical_min = 0 - 2.048 = -2.048 physical_max = 5 - 2.048 = 2.952 If these signals were acquired with a 14-bit ADC, then: digital_min = 0 digital_max = 2**14 - 1 = 16383 and thus: m = (physical_max - physical_min) / (digital_max - digital_min) m = (2.952 + 2.048) / (16383 - 0) m = 5 / 16383 = 0.00031 b = offset = physical_max / m - digital_max = -23093.4768 y = m * x + b physical_value = 0.00031 * (digital_value + -23093.4768)","title":"Example 2"},{"location":"usage/writing/","text":"","title":"Writing data"}]}